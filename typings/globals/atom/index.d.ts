// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/emitter.d.ts
declare module '~atom~atom-keymap~event-kit/lib/emitter' {
import Disposable = require('~atom~atom-keymap~event-kit/lib/disposable');
class Emitter {
  clear(): void;
  dispose(): void;
  on(eventName: string, handler: (value: any) => void): Disposable;
  preempt(eventName: string, handler: (value: any) => void): Disposable;
  emit(eventName: string, value: any): void;
}

export = Emitter;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/disposable.d.ts
declare module '~atom~atom-keymap~event-kit/lib/disposable' {
class Disposable {
  static isDisposable(object: Object): boolean;
  constructor(disposalAction: Function);
  dispose(): void;
}

export = Disposable;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/composite-disposable.d.ts
declare module '~atom~atom-keymap~event-kit/lib/composite-disposable' {
class CompositeDisposable {
  constructor(...disposables: { dispose: () => any }[]);
  dispose(): void;
  add(...disposables: { dispose: () => any }[]): void;
  remove(disposable: { dispose: () => any }): void;
  clear(): void;
}

export = CompositeDisposable;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/event-kit.d.ts
declare module '~atom~atom-keymap~event-kit/lib/event-kit' {
import EmitterS = require('~atom~atom-keymap~event-kit/lib/emitter');
import DisposableS = require('~atom~atom-keymap~event-kit/lib/disposable');
import CompositeDisposableS = require('~atom~atom-keymap~event-kit/lib/composite-disposable');


namespace EventKit {
  export class Emitter extends EmitterS { }
  export class Disposable extends DisposableS { }
  export class CompositeDisposable extends CompositeDisposableS { }
  export interface EventCallback {
    (event: any): void;
  }

  export interface EventHandler {
    (callback: () => void): DisposableS;
  }
}
export = EventKit;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-atom-keymap/d15fe03e94c1b2f5f77d0f6f1496175a8636d778/lib/key-binding.d.ts
declare module '~atom~atom-keymap/lib/key-binding' {
class KeyBinding {
  enabled: boolean;
  matches(keystroke: string): boolean;
  compare(keyBinding: KeyBinding): number;
}

export = KeyBinding;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-atom-keymap/d15fe03e94c1b2f5f77d0f6f1496175a8636d778/lib/keymap-manager.d.ts
declare module 'atom-keymap' {
import EventKit = require('~atom~atom-keymap~event-kit/lib/event-kit');
import KeyBinding = require('~atom~atom-keymap/lib/key-binding');

interface KeyOption {
  ctrl?: boolean;
  alt?: boolean;
  shift?: boolean;
  cmd?: boolean;
  which?: number;
  target: any; // ELEMNT?
}

class KeymapManager {
  static buildKeydownEvent(key: string, options?: KeyOption): void;
  constructor(options: { defaultTarget?: any });
  clear(): void;
  destroy(): void;

  // Event Subscription
  onDidMatchBinding(callback: (event: {
    keystrokes: string;
    binding: KeyBinding;
    keyboardEventTarget: any; // DOM element
  }) => void): EventKit.Disposable;
  onDidPartiallyMatchBindings(callback: (event: {
    keystrokes: string;
    partiallyMatchedBindings: KeyBinding[];
    keyboardEventTarget: any;
  }) => void): EventKit.Disposable;
  onDidFailToMatchBinding(callback: (event: {
    keystrokes: string;
    keyboardEventTarget: any;
  }) => void): EventKit.Disposable;
  onDidFailToReadFile(callback: (error: {
    message: string;
    stack: string;
  }) => void): EventKit.Disposable;

  // Adding and Removing Bindings
  add(source: string, bindings: Object, priority: number): void;

  // Accessing Bindings
  getKeyBindings(): KeyBinding[];
  findKeyBindings(params: {
    keystrokes: string;
    command: string;
    target: any
  }): KeyBinding[];
  loadKeymap(path: string, options: {
    watch: boolean;
    priority: number;
  }): void;
  watchKeymap(path: string, options: {
    priority: number;
  }): void;

  // Managing Keyboard Events
  handleKeyboardEvent(event: KeyboardEvent): void;
  keystrokeForKeyboardEvent(event: KeyboardEvent): string;
  getPartialMatchTimeout(): number;
}

export = KeymapManager;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/3ad17c029eb8899b613cdf8229964e67fb19cef7/lib/event-kit.d.ts
declare module 'event-kit' {
namespace EventKit {
  class Emitter {
    clear(): void;
    dispose(): void;
    on(eventName: string, handler: (value: any) => void): Disposable;
    preempt(eventName: string, handler: (value: any) => void): Disposable;
    emit(eventName: string, value: any): void;
  }

  class Disposable {
    static isDisposable(object: Object): boolean;
    constructor(disposalAction: Function);
    dispose(): void;
  }

  class CompositeDisposable {
    constructor(...disposables: { dispose: () => any }[]);
    dispose(): void;
    add(...disposables: { dispose: () => any }[]): void;
    remove(disposable: { dispose: () => any }): void;
    clear(): void;
  }

  interface EventCallback {
    (event: any): void;
  }

  interface EventHandler {
    (callback: () => void): Disposable;
  }
}

export = EventKit;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/grammar.d.ts
declare module '~atom~first-mate/lib/grammar' {
import EventKit = require('~atom~event-kit/lib/event-kit');

import GrammarRegistry = require('~atom~first-mate/lib/grammar-registry');

class Grammar {
  constructor(registry: GrammarRegistry, options?: Object);

  onDidUpdate: (callback: () => void) => EventKit.Disposable;
  tokenizeLines(text: string): any[];
  tokenizeLine(line: string, ruleStack?: any[], firstLine?: boolean): {
    line: string;
    tags: number[];
    tokens(): any;
    ruleStack: any[];
  };
}

export = Grammar;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/grammar-registry.d.ts
declare module '~atom~first-mate/lib/grammar-registry' {
import EventKit = require('~atom~event-kit/lib/event-kit');

import Grammar = require('~atom~first-mate/lib/grammar');

import GrammarEventHandler = require('~atom~first-mate/lib/grammar-event-handler');

class GrammarRegistry {
  onDidAddGrammar: GrammarEventHandler;
  onDidUpdateGrammar: GrammarEventHandler;
  getGrammars(): Grammar[];
  grammarForScopeName(scopeName: string): Grammar;
  addGrammar(grammar: Grammar): EventKit.Disposable;
  removeGrammarForScopeName(scopeName: string): Grammar;
  readGrammarSync(grammarPath: string): Grammar;
  readGrammar(grammarPath: string, callback: (err: Error, grammar: Grammar) => void): void;
  loadGrammarSync(grammarPath: string): Grammar;
  loadGrammar(grammarPath: string, callback: (err: Error, grammar: Grammar) => void): void;
}

export = GrammarRegistry;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/scope-selector.d.ts
declare module '~atom~first-mate/lib/scope-selector' {
class ScopeSelector {
  constructor(source: string);

  matches(scopes: string | string[]) : boolean;
  toCssSelector(): string;
}

export = ScopeSelector;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/grammar-event-handler.d.ts
declare module '~atom~first-mate/lib/grammar-event-handler' {
import EventKit = require('~atom~event-kit/lib/event-kit');
import Grammar = require('~atom~first-mate/lib/grammar');

interface GrammarEventHandler {
  (callback: (grammar: Grammar) => void): EventKit.Disposable;
}


export = GrammarEventHandler;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/first-mate.d.ts
declare module 'first-mate' {
import Grammar = require('~atom~first-mate/lib/grammar');
import GrammarRegistry = require('~atom~first-mate/lib/grammar-registry');
import ScopeSelector = require('~atom~first-mate/lib/scope-selector');
import GrammarEventHandler = require('~atom~first-mate/lib/grammar-event-handler');

export {Grammar}
export {GrammarRegistry}
export {ScopeSelector}
export {GrammarEventHandler}
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-pathwatcher/a40728b979faadbd2a9f9a3fe472d9350a06bf81/lib/file.d.ts
declare module '~atom~pathwatcher/lib/file' {

import Directory = require('~atom~pathwatcher/lib/directory');

class File {
  constructor(filePath: string, symlink?: boolean);
  create(): PromiseLike<boolean>;
  onDidChange(callback: () => void): void;
  onDidRename(callback: () => void): void;
  onDidDelete(callback: () => void): void;
  onWillThrowWatchError(callback: (errorObject: {
    error: Object;
    handle(): void
  }) => void): void;
  isFile(): boolean;
  isDirectory(): boolean;
  isSymbolicLink(): boolean;
  exists(): PromiseLike<boolean>;
  existsSync(): boolean;
  getDigest(): PromiseLike<string>;
  getDigestSync(): string;
  setEncoding(encoding: string): void;
  getEncoding(): string;
  getPath(): string;
  getRealPathSync(): string;
  getRealPath(): PromiseLike<string>;
  getBaseName(): string;
  getParent(): Directory;
  read(flushCache: boolean): PromiseLike<string>;
  write(text: string): PromiseLike<void>;
  writeSync(text: string): void;
}

export = File;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-pathwatcher/a40728b979faadbd2a9f9a3fe472d9350a06bf81/lib/directory.d.ts
declare module '~atom~pathwatcher/lib/directory' {

import EventKit = require('~atom~event-kit/lib/event-kit');

class Directory {
  constructor(directoryPath: string, symlink?: boolean);
  create(mode?: number): PromiseLike<boolean>;
  onDidChange: (callback: () => void) => EventKit.Disposable;
  isFile(): boolean;
  isDirectory(): boolean;
  isSymbolicLink(): boolean;
  exists(): PromiseLike<boolean>;
  existsSync(): boolean;
  isRoot(): boolean;
  getPath(): string;
  getRealPathSync(): string;
  getBaseName(): string;
  relativize(): string;
  getParent(): Directory;
  getFile(filename: string): File;
  getSubdirectory(dirname: string): Directory;
  getEntriesSync(): (File | Directory)[];
  getEntries(callback: (error: Error, entries: (File | Directory)[]) => void): void;
  contains(pathToCheck: string): boolean;
}

export = Directory;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-pathwatcher/a40728b979faadbd2a9f9a3fe472d9350a06bf81/lib/main.d.ts
declare module 'pathwatcher' {
import File = require('~atom~pathwatcher/lib/file');
import Directory = require('~atom~pathwatcher/lib/directory');

export function watch(path: string, callback: (event: any, newFilePath: string) => void)
export function closeAllWatchers(): void
export function getWatchedPaths(): string[]
export {File}
export {Directory}
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-text-buffer/5f6832aa04fc0f0634c216a9d0a88c3701a7e8fd/lib/text-buffer.d.ts
declare module 'text-buffer' {
import EventKit = require('~atom~atom-keymap~event-kit/lib/event-kit');

namespace TextBuffer {
  class Point {
    static fromObject(object: Point | number[], copy?: boolean): Point;
    static min(point1: Point, point2: Point): Point;
    row: number;
    column: number;
    constructor(row: number, column: number);
    copy(): Point;
    negate(): Point;

    compare(other: Point): Point;
    isEqual(other: Point): boolean;
    isLessThan(other: Point): boolean;
    isLessThanOrEqual(other: Point): boolean;
    isGreaterThan(other: Point): boolean;
    isGreaterThanOrEqual(other: Point): boolean;
    freeze(): void;
    translate(other: Point): Point;
    traverse(other: Point): Point;
    toArray(): number[];
    serialize(): number[];
    toString(): string;
  }

  class Range {
    start: Point;
    end: Point;
    static fromObject(object: Range | Point[], copy?: boolean): Range;
    constructor(pointA: Point, pointB: Point);
    copy(): Range;
    negate(): Range;

    static deserialize(array: any): Range;
    serialize(): any;

    isEmpty(): boolean;
    isSingleLine(): boolean;
    getRowCount(): number;
    getRows(): number[];

    freeze(): void;
    union(otherRange: Range): Range;
    translate(startDelta: Point, endDelta?: Point): Range;
    traverse(delta: Point): Range;


    compare(otherRange: Range): Range;
    isEqual(otherRange: Range): boolean;
    coversSameRows(otherRange: Range): boolean;
    intersectsWith(otherRange: Range, exclusive?: boolean): boolean;
    containsRange(otherRange: Range, exclusive?: boolean): boolean;
    containsPoint(point: Point, exclusive?: boolean): boolean;
    intersectsRow(row: number): boolean;
    intersectsRowRange(startRow: number, endRow: number): boolean;
    toString(): string;
  }

  class Marker {
    constructor(id, layer, range: Range, params: Object);
    onDidDestroy: EventKit.EventHandler;
    onDidChange(callback: (event: {
      oldHeadBufferPosition: Point;
      newHeadBufferPosition: Point;
      oldTailBufferPosition: Point;
      newTailBufferPosition: Point;
      oldHeadScreenPosition: Point;
      newHeadScreenPosition: Point;
      oldTailScreenPosition: Point;
      newTailScreenPosition: Point;
      wasValid: boolean;
      isValid: boolean;
      hadTail: boolean;
      hasTail: boolean;
      oldProperties: Object;
      newProperties: Object;
      textChanged: boolean;
    }) => void): EventKit.Disposable;
    getRange(): Range;
    setRange(range: Range, params?: { reversed?: boolean, exclusive?: boolean }): void;
    getHeadPosition(): Position;
    setHeadPosition(position: Position): void;
    getTailPosition(): Position;
    setTailPosition(position: Position): void;
    getStartPosition(): Position;
    getEndPosition(): Position;
    clearTail(): void;
    plantTail(): void;
    isReversed(): boolean;
    hasTail(): boolean;
    isValid(): boolean;
    isDestroyed(): boolean;
    isExclusive(): boolean;
    isEqual(other: Marker): boolean;
    getInvalidationStrategy(): string;
    getProperties(): Object;
    setProperties(properties: Object): void;
    copy(option?: Object): Marker;
    destroy(): void;
    compare(other: Marker): boolean;
  }
  class MarkerLayer {
    // Lifecycle
    copy(): void;
    destroy(): void;
    isDestroyed(): boolean;
    // Querying
    getMarker(): Marker;
    getMarkers(): Marker[];
    getMarkerCount(): number;
    /**
     * @params params A hash of key-value pairs constraining the set of returned markers.
     * You can query against custom marker properties by listing the desired key-value pairs here.
     * In addition, the following keys are reserved and have special semantics:
     *    startPosition	Only include markers that start at the given Point.
     *    endPosition Only include markers that end at the given Point.
     *    containsPoint Only include markers that contain the given Point, inclusive.
     *    containsRange	Only include markers that contain the given Range, inclusive.
     *    startRow Only include markers that start at the given row Number.
     *    endRow Only include markers that end at the given row Number.
     *    intersectsRow Only include markers that intersect the given row Number.
     */
    findMarkers(params: {
      startPosition?: Point,
      endPosition?: Point,
      containsPoint?: Point,
      containsRange?: Range,
      startRow?: number,
      endRow?: number;
      intersectsRow?: number
    }): Marker[];
    // Marker creation
    markRange(range: Range | Point[], properties: {
      reversed?: boolean,
      persistent?: boolean,
      invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
    }): Marker;
    markPosition(position: Point | number[], properties: {
      reversed?: boolean,
      persistent?: boolean,
      invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
    }): Marker;
    // Event subscription

    onDidUpdate: EventKit.EventHandler;
    onDidCreateMarker: EventKit.EventHandler;
    onDidDestroy(): EventKit.Disposable;
  }
  interface ScanFunction {
    (regex: RegExp, iterator: (match: any, matchText: string, range: Range, stop: Function, replace: (value: string) => void) => void): void;
  }
  interface ScanInRangeFunction {
    (regex: RegExp, range: Range, iterator: (match: any, matchText: string, range: Range, stop: Function, replace: (value: string) => void) => void): void;
  }
}

class TextBuffer {
  constructor(params: string | { load: boolean, text: string });
  onWillChange(callback: (event: {
    oldRange: Range,
    newRange: Range,
    oldText: string,
    newText: string
  }) => void): EventKit.Disposable;
  onDidChange(callback: (event: {
    oldRange: Range,
    newRange: Range,
    oldText: string,
    newText: string
  }) => void): EventKit.Disposable;
  onDidStopChanging: EventKit.EventHandler;
  onDidConflict: EventKit.EventHandler;
  onDidChangeModified(callback: (modified: boolean) => void): EventKit.Disposable;
  onDidUpdateMarkers: EventKit.EventHandler;
  onDidCreateMarker(callback: (marker: TextBuffer.Marker) => void): EventKit.Disposable;
  onDidChangePath(callback: (path: string) => void): EventKit.Disposable;
  onDidChangeEncoding(callback: (encoding: string) => void): EventKit.Disposable;
  onWillSave: EventKit.EventHandler;
  onDidSave(callback: (event: { path: string }) => void): EventKit.Disposable;
  onDidDelete: EventKit.EventHandler;
  onWillReload: EventKit.EventHandler;
  onDidReload: EventKit.EventHandler;
  onDidDestroy: EventKit.EventHandler;
  onWillThrowWatchError(callback: (errorObject: {
    error: Object,
    handle(): void
  }) => void): EventKit.Disposable;
  getStoppedChangingDelay(): number;
  isModified(): boolean;
  isInConflict(): boolean;
  getPath(): string;
  setPath(filePath: string): void;
  setEncoding(encoding: string): void;
  getEncoding(): string;
  getUri(): string;
  isEmpty(): boolean;
  getText(): string;
  getTextInRange(range: Range): string;
  getLines(): string[];
  getLastLine(): string;
  lineForRow(row: number): string;
  lineEndingForRow(row: number): '\n' | '\r' | '\r\n' | '';
  lineLengthForRow(row: number): number;
  isRowBlank(row: number): boolean;
  previousNonBlankRow(startRow: number): number;
  nextNonBlankRow(startRow: number): number;
  setText(text: string): Range;
  setTextViaDiff(text: string): any;
  setTextInRange(range: Range, text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  insert(position: TextBuffer.Point, text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  append(text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  delete(range: Range): Range;
  deleteRow(row: number): Range;
  deleteRows(startRow: number, endRow: number): Range;
  addMarkerLayer(options: { maintainHistory: boolean }): TextBuffer.MarkerLayer;
  getMarkerLayer(id: any): TextBuffer.MarkerLayer;
  markRange(range: Range | TextBuffer.Point[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextBuffer.Marker;
  markPosition(position: TextBuffer.Point | number[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextBuffer.Marker;
  getMarkers(): TextBuffer.Marker[];
  getMarker(id: number): TextBuffer.Marker;
  /**
   * @params params A hash of key-value pairs constraining the set of returned markers.
   * You can query against custom marker properties by listing the desired key-value pairs here.
   * In addition, the following keys are reserved and have special semantics:
   *    startPosition	Only include markers that start at the given Point.
   *    endPosition Only include markers that end at the given Point.
   *    containsPoint Only include markers that contain the given Point, inclusive.
   *    containsRange	Only include markers that contain the given Range, inclusive.
   *    startRow Only include markers that start at the given row Number.
   *    endRow Only include markers that end at the given row Number.
   *    intersectsRow Only include markers that intersect the given row Number.
   */
  findMarkers(params: {
    startPosition?: TextBuffer.Point,
    endPosition?: TextBuffer.Point,
    containsPoint?: TextBuffer.Point,
    containsRange?: Range,
    startRow?: number,
    endRow?: number;
    intersectsRow?: number
  }): TextBuffer.Marker[];
  getMarkerCount(): number;
  undo(): void;
  redo(): void;
  transact(fn: () => void): void;
  transact(groupingInterval: number, fn: () => void): void;
  clearUndoStack(): void;
  createCheckpoint(): any;
  revertToCheckpoint(): boolean;
  groupChangesSinceCheckpoint(): boolean;
  scan: TextBuffer.ScanFunction;
  backwardsScan: TextBuffer.ScanFunction;
  scanInRange: TextBuffer.ScanInRangeFunction;
  backwardsScanInRange: TextBuffer.ScanInRangeFunction;
  replace(regex: RegExp, replacementText: string): number;
  getRange(): Range;
  getLineCount(): number;
  getLastRow(): number;

  getFirstPosition(): TextBuffer.Point;
  getEndPosition(): TextBuffer.Point;
  getMaxCharacterIndex(): number;
  rangeForRow(row: number, includeNewline: boolean): Range;
  characterIndexForPosition(position: TextBuffer.Point): number;
  positionForCharacterIndex(offset: number): TextBuffer.Point;
  clipRange(range: Range): Range;
  clipPosition(position: TextBuffer.Point): TextBuffer.Point;
  save(): void;
  saveAs(filePath: string): void;
  reload(): void;
}

export = TextBuffer;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/types/env-atom/7582c188a2567744ea471e352e650c4f0ea3259a/dist/atom.d.ts
declare module '~atom~event-kit/lib/event-kit' {
namespace EventKit {
  class Emitter {
    clear(): void;
    dispose(): void;
    on(eventName: string, handler: (value: any) => void): Disposable;
    preempt(eventName: string, handler: (value: any) => void): Disposable;
    emit(eventName: string, value: any): void;
  }

  class Disposable {
    static isDisposable(object: Object): boolean;
    constructor(disposalAction: Function);
    dispose(): void;
  }

  class CompositeDisposable {
    constructor(...disposables: { dispose: () => any }[]);
    dispose(): void;
    add(...disposables: { dispose: () => any }[]): void;
    remove(disposable: { dispose: () => any }): void;
    clear(): void;
  }

  interface EventCallback {
    (event: any): void;
  }

  interface EventHandler {
    (callback: () => void): Disposable;
  }
}

export = EventKit;
}
declare module '~atom~event-kit' {
import alias = require('~atom~event-kit/lib/event-kit');
export = alias;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/emitter.d.ts
declare module '~atom~atom-keymap~event-kit/lib/emitter' {
import Disposable = require('~atom~atom-keymap~event-kit/lib/disposable');
class Emitter {
  clear(): void;
  dispose(): void;
  on(eventName: string, handler: (value: any) => void): Disposable;
  preempt(eventName: string, handler: (value: any) => void): Disposable;
  emit(eventName: string, value: any): void;
}

export = Emitter;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/disposable.d.ts
declare module '~atom~atom-keymap~event-kit/lib/disposable' {
class Disposable {
  static isDisposable(object: Object): boolean;
  constructor(disposalAction: Function);
  dispose(): void;
}

export = Disposable;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/composite-disposable.d.ts
declare module '~atom~atom-keymap~event-kit/lib/composite-disposable' {
class CompositeDisposable {
  constructor(...disposables: { dispose: () => any }[]);
  dispose(): void;
  add(...disposables: { dispose: () => any }[]): void;
  remove(disposable: { dispose: () => any }): void;
  clear(): void;
}

export = CompositeDisposable;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/event-kit.d.ts
declare module '~atom~atom-keymap~event-kit/lib/event-kit' {
import EmitterS = require('~atom~atom-keymap~event-kit/lib/emitter');
import DisposableS = require('~atom~atom-keymap~event-kit/lib/disposable');
import CompositeDisposableS = require('~atom~atom-keymap~event-kit/lib/composite-disposable');


namespace EventKit {
  export class Emitter extends EmitterS { }
  export class Disposable extends DisposableS { }
  export class CompositeDisposable extends CompositeDisposableS { }
  export interface EventCallback {
    (event: any): void;
  }

  export interface EventHandler {
    (callback: () => void): DisposableS;
  }
}
export = EventKit;
}
declare module '~atom~atom-keymap~event-kit' {
import alias = require('~atom~atom-keymap~event-kit/lib/event-kit');
export = alias;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-atom-keymap/d15fe03e94c1b2f5f77d0f6f1496175a8636d778/lib/key-binding.d.ts
declare module '~atom~atom-keymap/lib/key-binding' {
class KeyBinding {
  enabled: boolean;
  matches(keystroke: string): boolean;
  compare(keyBinding: KeyBinding): number;
}

export = KeyBinding;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-atom-keymap/d15fe03e94c1b2f5f77d0f6f1496175a8636d778/lib/keymap-manager.d.ts
declare module '~atom~atom-keymap/lib/keymap-manager' {
import EventKit = require('~atom~atom-keymap~event-kit');
import KeyBinding = require('~atom~atom-keymap/lib/key-binding');

interface KeyOption {
  ctrl?: boolean;
  alt?: boolean;
  shift?: boolean;
  cmd?: boolean;
  which?: number;
  target: any; // ELEMNT?
}

class KeymapManager {
  static buildKeydownEvent(key: string, options?: KeyOption): void;
  constructor(options: { defaultTarget?: any });
  clear(): void;
  destroy(): void;

  // Event Subscription
  onDidMatchBinding(callback: (event: {
    keystrokes: string;
    binding: KeyBinding;
    keyboardEventTarget: any; // DOM element
  }) => void): EventKit.Disposable;
  onDidPartiallyMatchBindings(callback: (event: {
    keystrokes: string;
    partiallyMatchedBindings: KeyBinding[];
    keyboardEventTarget: any;
  }) => void): EventKit.Disposable;
  onDidFailToMatchBinding(callback: (event: {
    keystrokes: string;
    keyboardEventTarget: any;
  }) => void): EventKit.Disposable;
  onDidFailToReadFile(callback: (error: {
    message: string;
    stack: string;
  }) => void): EventKit.Disposable;

  // Adding and Removing Bindings
  add(source: string, bindings: Object, priority: number): void;

  // Accessing Bindings
  getKeyBindings(): KeyBinding[];
  findKeyBindings(params: {
    keystrokes: string;
    command: string;
    target: any
  }): KeyBinding[];
  loadKeymap(path: string, options: {
    watch: boolean;
    priority: number;
  }): void;
  watchKeymap(path: string, options: {
    priority: number;
  }): void;

  // Managing Keyboard Events
  handleKeyboardEvent(event: KeyboardEvent): void;
  keystrokeForKeyboardEvent(event: KeyboardEvent): string;
  getPartialMatchTimeout(): number;
}

export = KeymapManager;
}
declare module '~atom~atom-keymap' {
import alias = require('~atom~atom-keymap/lib/keymap-manager');
export = alias;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/3ad17c029eb8899b613cdf8229964e67fb19cef7/lib/event-kit.d.ts
declare module '~atom~first-mate~event-kit/lib/event-kit' {
namespace EventKit {
  class Emitter {
    clear(): void;
    dispose(): void;
    on(eventName: string, handler: (value: any) => void): Disposable;
    preempt(eventName: string, handler: (value: any) => void): Disposable;
    emit(eventName: string, value: any): void;
  }

  class Disposable {
    static isDisposable(object: Object): boolean;
    constructor(disposalAction: Function);
    dispose(): void;
  }

  class CompositeDisposable {
    constructor(...disposables: { dispose: () => any }[]);
    dispose(): void;
    add(...disposables: { dispose: () => any }[]): void;
    remove(disposable: { dispose: () => any }): void;
    clear(): void;
  }

  interface EventCallback {
    (event: any): void;
  }

  interface EventHandler {
    (callback: () => void): Disposable;
  }
}

export = EventKit;
}
declare module '~atom~first-mate~event-kit' {
import alias = require('~atom~first-mate~event-kit/lib/event-kit');
export = alias;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/grammar.d.ts
declare module '~atom~first-mate/lib/grammar' {
import EventKit = require('~atom~first-mate~event-kit');

import GrammarRegistry = require('~atom~first-mate/lib/grammar-registry');

class Grammar {
  constructor(registry: GrammarRegistry, options?: Object);

  onDidUpdate: (callback: () => void) => EventKit.Disposable;
  tokenizeLines(text: string): any[];
  tokenizeLine(line: string, ruleStack?: any[], firstLine?: boolean): {
    line: string;
    tags: number[];
    tokens(): any;
    ruleStack: any[];
  };
}

export = Grammar;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/grammar-registry.d.ts
declare module '~atom~first-mate/lib/grammar-registry' {
import EventKit = require('~atom~first-mate~event-kit');

import Grammar = require('~atom~first-mate/lib/grammar');

import GrammarEventHandler = require('~atom~first-mate/lib/grammar-event-handler');

class GrammarRegistry {
  onDidAddGrammar: GrammarEventHandler;
  onDidUpdateGrammar: GrammarEventHandler;
  getGrammars(): Grammar[];
  grammarForScopeName(scopeName: string): Grammar;
  addGrammar(grammar: Grammar): EventKit.Disposable;
  removeGrammarForScopeName(scopeName: string): Grammar;
  readGrammarSync(grammarPath: string): Grammar;
  readGrammar(grammarPath: string, callback: (err: Error, grammar: Grammar) => void): void;
  loadGrammarSync(grammarPath: string): Grammar;
  loadGrammar(grammarPath: string, callback: (err: Error, grammar: Grammar) => void): void;
}

export = GrammarRegistry;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/scope-selector.d.ts
declare module '~atom~first-mate/lib/scope-selector' {
class ScopeSelector {
  constructor(source: string);

  matches(scopes: string | string[]) : boolean;
  toCssSelector(): string;
}

export = ScopeSelector;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/grammar-event-handler.d.ts
declare module '~atom~first-mate/lib/grammar-event-handler' {
import EventKit = require('~atom~first-mate~event-kit');
import Grammar = require('~atom~first-mate/lib/grammar');

interface GrammarEventHandler {
  (callback: (grammar: Grammar) => void): EventKit.Disposable;
}


export = GrammarEventHandler;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-first-mate/0e9e3631d2a42c97d6d720ac549a10ae9ba68117/lib/first-mate.d.ts
declare module '~atom~first-mate/lib/first-mate' {
import Grammar = require('~atom~first-mate/lib/grammar');
import GrammarRegistry = require('~atom~first-mate/lib/grammar-registry');
import ScopeSelector = require('~atom~first-mate/lib/scope-selector');
import GrammarEventHandler = require('~atom~first-mate/lib/grammar-event-handler');

export {Grammar}
export {GrammarRegistry}
export {ScopeSelector}
export {GrammarEventHandler}
}
declare module '~atom~first-mate' {
import alias = require('~atom~first-mate/lib/first-mate');
export = alias;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/emitter.d.ts
declare module '~atom~text-buffer~event-kit/lib/emitter' {
import Disposable = require('~atom~text-buffer~event-kit/lib/disposable');
class Emitter {
  clear(): void;
  dispose(): void;
  on(eventName: string, handler: (value: any) => void): Disposable;
  preempt(eventName: string, handler: (value: any) => void): Disposable;
  emit(eventName: string, value: any): void;
}

export = Emitter;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/disposable.d.ts
declare module '~atom~text-buffer~event-kit/lib/disposable' {
class Disposable {
  static isDisposable(object: Object): boolean;
  constructor(disposalAction: Function);
  dispose(): void;
}

export = Disposable;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/composite-disposable.d.ts
declare module '~atom~text-buffer~event-kit/lib/composite-disposable' {
class CompositeDisposable {
  constructor(...disposables: { dispose: () => any }[]);
  dispose(): void;
  add(...disposables: { dispose: () => any }[]): void;
  remove(disposable: { dispose: () => any }): void;
  clear(): void;
}

export = CompositeDisposable;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/6b7089b288313f8e9a4cc79bd5c3776a6fcb9647/lib/event-kit.d.ts
declare module '~atom~text-buffer~event-kit/lib/event-kit' {
import EmitterS = require('~atom~text-buffer~event-kit/lib/emitter');
import DisposableS = require('~atom~text-buffer~event-kit/lib/disposable');
import CompositeDisposableS = require('~atom~text-buffer~event-kit/lib/composite-disposable');


namespace EventKit {
  export class Emitter extends EmitterS { }
  export class Disposable extends DisposableS { }
  export class CompositeDisposable extends CompositeDisposableS { }
  export interface EventCallback {
    (event: any): void;
  }

  export interface EventHandler {
    (callback: () => void): DisposableS;
  }
}
export = EventKit;
}
declare module '~atom~text-buffer~event-kit' {
import alias = require('~atom~text-buffer~event-kit/lib/event-kit');
export = alias;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-text-buffer/5f6832aa04fc0f0634c216a9d0a88c3701a7e8fd/lib/text-buffer.d.ts
declare module '~atom~text-buffer/lib/text-buffer' {
import EventKit = require('~atom~text-buffer~event-kit');

namespace TextBuffer {
  class Point {
    static fromObject(object: Point | number[], copy?: boolean): Point;
    static min(point1: Point, point2: Point): Point;
    row: number;
    column: number;
    constructor(row: number, column: number);
    copy(): Point;
    negate(): Point;

    compare(other: Point): Point;
    isEqual(other: Point): boolean;
    isLessThan(other: Point): boolean;
    isLessThanOrEqual(other: Point): boolean;
    isGreaterThan(other: Point): boolean;
    isGreaterThanOrEqual(other: Point): boolean;
    freeze(): void;
    translate(other: Point): Point;
    traverse(other: Point): Point;
    toArray(): number[];
    serialize(): number[];
    toString(): string;
  }

  class Range {
    start: Point;
    end: Point;
    static fromObject(object: Range | Point[], copy?: boolean): Range;
    constructor(pointA: Point, pointB: Point);
    copy(): Range;
    negate(): Range;

    static deserialize(array: any): Range;
    serialize(): any;

    isEmpty(): boolean;
    isSingleLine(): boolean;
    getRowCount(): number;
    getRows(): number[];

    freeze(): void;
    union(otherRange: Range): Range;
    translate(startDelta: Point, endDelta?: Point): Range;
    traverse(delta: Point): Range;


    compare(otherRange: Range): Range;
    isEqual(otherRange: Range): boolean;
    coversSameRows(otherRange: Range): boolean;
    intersectsWith(otherRange: Range, exclusive?: boolean): boolean;
    containsRange(otherRange: Range, exclusive?: boolean): boolean;
    containsPoint(point: Point, exclusive?: boolean): boolean;
    intersectsRow(row: number): boolean;
    intersectsRowRange(startRow: number, endRow: number): boolean;
    toString(): string;
  }

  class Marker {
    constructor(id, layer, range: Range, params: Object);
    onDidDestroy: EventKit.EventHandler;
    onDidChange(callback: (event: {
      oldHeadBufferPosition: Point;
      newHeadBufferPosition: Point;
      oldTailBufferPosition: Point;
      newTailBufferPosition: Point;
      oldHeadScreenPosition: Point;
      newHeadScreenPosition: Point;
      oldTailScreenPosition: Point;
      newTailScreenPosition: Point;
      wasValid: boolean;
      isValid: boolean;
      hadTail: boolean;
      hasTail: boolean;
      oldProperties: Object;
      newProperties: Object;
      textChanged: boolean;
    }) => void): EventKit.Disposable;
    getRange(): Range;
    setRange(range: Range, params?: { reversed?: boolean, exclusive?: boolean }): void;
    getHeadPosition(): Position;
    setHeadPosition(position: Position): void;
    getTailPosition(): Position;
    setTailPosition(position: Position): void;
    getStartPosition(): Position;
    getEndPosition(): Position;
    clearTail(): void;
    plantTail(): void;
    isReversed(): boolean;
    hasTail(): boolean;
    isValid(): boolean;
    isDestroyed(): boolean;
    isExclusive(): boolean;
    isEqual(other: Marker): boolean;
    getInvalidationStrategy(): string;
    getProperties(): Object;
    setProperties(properties: Object): void;
    copy(option?: Object): Marker;
    destroy(): void;
    compare(other: Marker): boolean;
  }
  class MarkerLayer {
    // Lifecycle
    copy(): void;
    destroy(): void;
    isDestroyed(): boolean;
    // Querying
    getMarker(): Marker;
    getMarkers(): Marker[];
    getMarkerCount(): number;
    /**
     * @params params A hash of key-value pairs constraining the set of returned markers.
     * You can query against custom marker properties by listing the desired key-value pairs here.
     * In addition, the following keys are reserved and have special semantics:
     *    startPosition	Only include markers that start at the given Point.
     *    endPosition Only include markers that end at the given Point.
     *    containsPoint Only include markers that contain the given Point, inclusive.
     *    containsRange	Only include markers that contain the given Range, inclusive.
     *    startRow Only include markers that start at the given row Number.
     *    endRow Only include markers that end at the given row Number.
     *    intersectsRow Only include markers that intersect the given row Number.
     */
    findMarkers(params: {
      startPosition?: Point,
      endPosition?: Point,
      containsPoint?: Point,
      containsRange?: Range,
      startRow?: number,
      endRow?: number;
      intersectsRow?: number
    }): Marker[];
    // Marker creation
    markRange(range: Range | Point[], properties: {
      reversed?: boolean,
      persistent?: boolean,
      invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
    }): Marker;
    markPosition(position: Point | number[], properties: {
      reversed?: boolean,
      persistent?: boolean,
      invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
    }): Marker;
    // Event subscription

    onDidUpdate: EventKit.EventHandler;
    onDidCreateMarker: EventKit.EventHandler;
    onDidDestroy(): EventKit.Disposable;
  }
  interface ScanFunction {
    (regex: RegExp, iterator: (match: any, matchText: string, range: Range, stop: Function, replace: (value: string) => void) => void): void;
  }
  interface ScanInRangeFunction {
    (regex: RegExp, range: Range, iterator: (match: any, matchText: string, range: Range, stop: Function, replace: (value: string) => void) => void): void;
  }
}

class TextBuffer {
  constructor(params: string | { load: boolean, text: string });
  onWillChange(callback: (event: {
    oldRange: Range,
    newRange: Range,
    oldText: string,
    newText: string
  }) => void): EventKit.Disposable;
  onDidChange(callback: (event: {
    oldRange: Range,
    newRange: Range,
    oldText: string,
    newText: string
  }) => void): EventKit.Disposable;
  onDidStopChanging: EventKit.EventHandler;
  onDidConflict: EventKit.EventHandler;
  onDidChangeModified(callback: (modified: boolean) => void): EventKit.Disposable;
  onDidUpdateMarkers: EventKit.EventHandler;
  onDidCreateMarker(callback: (marker: TextBuffer.Marker) => void): EventKit.Disposable;
  onDidChangePath(callback: (path: string) => void): EventKit.Disposable;
  onDidChangeEncoding(callback: (encoding: string) => void): EventKit.Disposable;
  onWillSave: EventKit.EventHandler;
  onDidSave(callback: (event: { path: string }) => void): EventKit.Disposable;
  onDidDelete: EventKit.EventHandler;
  onWillReload: EventKit.EventHandler;
  onDidReload: EventKit.EventHandler;
  onDidDestroy: EventKit.EventHandler;
  onWillThrowWatchError(callback: (errorObject: {
    error: Object,
    handle(): void
  }) => void): EventKit.Disposable;
  getStoppedChangingDelay(): number;
  isModified(): boolean;
  isInConflict(): boolean;
  getPath(): string;
  setPath(filePath: string): void;
  setEncoding(encoding: string): void;
  getEncoding(): string;
  getUri(): string;
  isEmpty(): boolean;
  getText(): string;
  getTextInRange(range: Range): string;
  getLines(): string[];
  getLastLine(): string;
  lineForRow(row: number): string;
  lineEndingForRow(row: number): '\n' | '\r' | '\r\n' | '';
  lineLengthForRow(row: number): number;
  isRowBlank(row: number): boolean;
  previousNonBlankRow(startRow: number): number;
  nextNonBlankRow(startRow: number): number;
  setText(text: string): Range;
  setTextViaDiff(text: string): any;
  setTextInRange(range: Range, text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  insert(position: TextBuffer.Point, text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  append(text: string, options?: { normalizeLineEndings?: boolean, undo?: 'skip' }): Range;
  delete(range: Range): Range;
  deleteRow(row: number): Range;
  deleteRows(startRow: number, endRow: number): Range;
  addMarkerLayer(options: { maintainHistory: boolean }): TextBuffer.MarkerLayer;
  getMarkerLayer(id: any): TextBuffer.MarkerLayer;
  markRange(range: Range | TextBuffer.Point[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextBuffer.Marker;
  markPosition(position: TextBuffer.Point | number[], properties: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextBuffer.Marker;
  getMarkers(): TextBuffer.Marker[];
  getMarker(id: number): TextBuffer.Marker;
  /**
   * @params params A hash of key-value pairs constraining the set of returned markers.
   * You can query against custom marker properties by listing the desired key-value pairs here.
   * In addition, the following keys are reserved and have special semantics:
   *    startPosition	Only include markers that start at the given Point.
   *    endPosition Only include markers that end at the given Point.
   *    containsPoint Only include markers that contain the given Point, inclusive.
   *    containsRange	Only include markers that contain the given Range, inclusive.
   *    startRow Only include markers that start at the given row Number.
   *    endRow Only include markers that end at the given row Number.
   *    intersectsRow Only include markers that intersect the given row Number.
   */
  findMarkers(params: {
    startPosition?: TextBuffer.Point,
    endPosition?: TextBuffer.Point,
    containsPoint?: TextBuffer.Point,
    containsRange?: Range,
    startRow?: number,
    endRow?: number;
    intersectsRow?: number
  }): TextBuffer.Marker[];
  getMarkerCount(): number;
  undo(): void;
  redo(): void;
  transact(fn: () => void): void;
  transact(groupingInterval: number, fn: () => void): void;
  clearUndoStack(): void;
  createCheckpoint(): any;
  revertToCheckpoint(): boolean;
  groupChangesSinceCheckpoint(): boolean;
  scan: TextBuffer.ScanFunction;
  backwardsScan: TextBuffer.ScanFunction;
  scanInRange: TextBuffer.ScanInRangeFunction;
  backwardsScanInRange: TextBuffer.ScanInRangeFunction;
  replace(regex: RegExp, replacementText: string): number;
  getRange(): Range;
  getLineCount(): number;
  getLastRow(): number;

  getFirstPosition(): TextBuffer.Point;
  getEndPosition(): TextBuffer.Point;
  getMaxCharacterIndex(): number;
  rangeForRow(row: number, includeNewline: boolean): Range;
  characterIndexForPosition(position: TextBuffer.Point): number;
  positionForCharacterIndex(offset: number): TextBuffer.Point;
  clipRange(range: Range): Range;
  clipPosition(position: TextBuffer.Point): TextBuffer.Point;
  save(): void;
  saveAs(filePath: string): void;
  reload(): void;
}

export = TextBuffer;
}
declare module '~atom~text-buffer' {
import alias = require('~atom~text-buffer/lib/text-buffer');
export = alias;
}

// Generated by typings
// Source: src/atom/buffer-process.d.ts
declare module '~atom/src/atom/buffer-process' {
import EventKit = require('~atom~event-kit');

class BufferedProcess {
  constructor(options: {
    command: string,
    args?: any[],
    options?: Object,
    stdout?: (data: string) => void;
    stderr?: (data: string) => void;
    exit?: (code: number) => void;
  });
  onWillThrowError(callback: (errorObject: { error: Object, handle(): void }) => void): EventKit.Disposable;
  kill(): void;
}


export = BufferedProcess;
}
declare module 'atom/src/atom/buffer-process' {
import alias = require('~atom/src/atom/buffer-process');
export = alias;
}

// Generated by typings
// Source: src/atom/buffer-node-process.d.ts
declare module '~atom/src/atom/buffer-node-process' {
import BufferedProcess = require('~atom/src/atom/buffer-process');
class BufferedNodeProcess extends BufferedProcess {
}

export = BufferedNodeProcess;
}
declare module 'atom/src/atom/buffer-node-process' {
import alias = require('~atom/src/atom/buffer-node-process');
export = alias;
}

// Generated by typings
// Source: src/atom/git-repository.d.ts
declare module '~atom/src/atom/git-repository' {
import EventKit = require('~atom~event-kit');

class GitRepository {
  static open(path: string, options?: { refreshOnWindowFocus: boolean }): GitRepository;
  destroy();
  onDidDestroy: (callback: () => void) => EventKit.Disposable;
  onDidChangeStatus(callback: (event: {
    path: string;
    pathStatus: number;
  }) => void): EventKit.Disposable;
  onDidChangeStatuses: (callback: () => void) => EventKit.Disposable;
  getType(): string;
  getPath(): string;
  getWorkingDirectory(): string;
  isProjectAtRoot(): boolean;
  relativize(): string;
  hasBranch(): boolean;
  getShortHead(path: string): string;
  isSubmodule(path: string): boolean;
  getAheadBehindCount(reference: string, path?: string): number;
  getCachedUpstreamAheadBehindCount(path: string): { ahead: number, behind: number };
  getConfigValue(path: string): any;
  getOriginURL(path?: string): string;
  getUpstreamBranch(path: string): string;
  getReferences(path: string): { heads: string[], remotes: string[], tags: string[] };
  getReferenceTarget(reference: string, path?: string): string;
  isPathModified(path: string): boolean;
  isPathNew(path: string): boolean;
  isPathIgnored(path): boolean;
  getDirectoryStatus(path: string): number;
  getPathStatus(): number;
  getCachedPathStatus(path: string): number;
  isStatusModified(status: boolean): boolean;
  isStatusNew(status: number): boolean;
  getDiffStats(path: string): { added: number, deleted: number };
  getLinkDiffs(path: string, text: string): { oldStart: number, newStart: number, oldLines: number, newLines: number }[];
  checkoutHead(path: string): boolean;
  checkoutReference(reference: string, create: boolean): boolean;
}


export = GitRepository;
}
declare module 'atom/src/atom/git-repository' {
import alias = require('~atom/src/atom/git-repository');
export = alias;
}

// Generated by typings
// Source: src/atom/notification.d.ts
declare module '~atom/src/atom/notification' {
import EventKit = require('~atom~event-kit');

class Notification {
  onDidDismiss: (callback: () => void) => EventKit.Disposable;
  onDidDisplay: (callback: () => void) => EventKit.Disposable;
  getType(): string;
  getMessage(): string;

  // Extended Methods
  dismiss(): void;
}

export = Notification;
}
declare module 'atom/src/atom/notification' {
import alias = require('~atom/src/atom/notification');
export = alias;
}

// Generated by typings
// Source: src/atom/command-registry.d.ts
declare module '~atom/src/atom/command-registry' {
import EventKit = require('~atom~event-kit');

interface CommandRegistry {
  add(target: string, commandName: string, callback: EventKit.EventCallback): any;
  findCommands(params: { target: any }): Array<{ name: string, displayName: string }>;
  dispatch(target: any, commandName: string): void;
  onWillDispatch(callback: EventKit.EventCallback): void;
  onDidDispatch(callback: EventKit.EventCallback): void;
}

export = CommandRegistry;
}
declare module 'atom/src/atom/command-registry' {
import alias = require('~atom/src/atom/command-registry');
export = alias;
}

// Generated by typings
// Source: src/atom/scope-descriptor.d.ts
declare module '~atom/src/atom/scope-descriptor' {
class ScopeDescriptor {
  constructor(options?: { scopes: string[] });
  getScopesArray(): string[];
}

export = ScopeDescriptor;
}
declare module 'atom/src/atom/scope-descriptor' {
import alias = require('~atom/src/atom/scope-descriptor');
export = alias;
}

// Generated by typings
// Source: src/atom/config.d.ts
declare module '~atom/src/atom/config' {
import ScopeDescriptor = require('~atom/src/atom/scope-descriptor');

interface ConfigOption {
  sources?: string[];
  excludeSources?: string[];
  scope?: ScopeDescriptor;
}

interface Config {
  get<T>(keyPath: string, options?: ConfigOption): T;
  set(keyPath: string, value: any, options?: { scopeSelector?: string, source?: string }): boolean;
  unset(keyPath: string, options?: { scopeSelector?: string, source?: string }): void;
  // Extended Methods
  getAll<T>(keyPath: string, options?: ConfigOption): { scopeDescriptor: ScopeDescriptor, value: T }[];
  getSources(): string[];
  getSchema(keyPath): any;
  getUserConfigPath(): string;
  transact(callback: () => void): void;
}

export = Config;
}
declare module 'atom/src/atom/config' {
import alias = require('~atom/src/atom/config');
export = alias;
}

// Generated by typings
// Source: src/atom/clipboard.d.ts
declare module '~atom/src/atom/clipboard' {
class Clipboard {
  write(text: string, metadata?: any): void;
  read(): string;
  readWithMetadata(): {
    text: string;
    metadata: any;
  };
}

export = Clipboard;
}
declare module 'atom/src/atom/clipboard' {
import alias = require('~atom/src/atom/clipboard');
export = alias;
}

// Generated by typings
// Source: src/atom/context-menu-manager.d.ts
declare module '~atom/src/atom/context-menu-manager' {
import EventKit = require('~atom~event-kit');

interface ContextMenuItem {
  label?: string;
  command?: string;
  enabled?: boolean;
  submenu?: ContextMenuItem[];
  type?: 'separator';
  visible?: boolean;
  created?: (event: EventKit.EventCallback) => void;
  shouldDisplay?: (event: EventKit.EventCallback) => void;
}

class ContextMenuManager {
  add(itemsBySelector: ContextMenuItem): EventKit.Disposable;
}

export = ContextMenuManager;
}
declare module 'atom/src/atom/context-menu-manager' {
import alias = require('~atom/src/atom/context-menu-manager');
export = alias;
}

// Generated by typings
// Source: src/atom/menu-manager.d.ts
declare module '~atom/src/atom/menu-manager' {
import EventKit = require('~atom~event-kit');

interface MenuItem {
  label: string;
  submenu?: MenuItem[];
  command?: string;
}

class MenuManager {
  add(items: MenuItem): EventKit.Disposable;
  update(): void;
}
export = MenuManager;
}
declare module 'atom/src/atom/menu-manager' {
import alias = require('~atom/src/atom/menu-manager');
export = alias;
}

// Generated by typings
// Source: src/atom/tooltip-manager.d.ts
declare module '~atom/src/atom/tooltip-manager' {
import EventKit = require('~atom~event-kit');

// Available in lib.d.ts?
interface JSTooltipOption {
  animation?: boolean;
  container?: string | boolean;
  delay?: number | { show: number, hide: number };
  html?: boolean;
  placement?: string | ((tooltipDomNode: any, triggeringElementDomNode: any) => string);
  selector?: string | boolean;
  template?: string;
  title?: string | (() => string);
  trigger?: string;
  viewport?: string | { selector: string, padding: number } | ((triggeringElementDomNode: any) => string | { selector: string, padding: number });
}

interface TooltipOption extends JSTooltipOption {
  keyBindingCommand?: string;
  keyBindingTarget?: HTMLElement;
}


class TooltipManager {
  add(target: HTMLElement, options: TooltipOption): EventKit.Disposable;
}

export = TooltipManager;
}
declare module 'atom/src/atom/tooltip-manager' {
import alias = require('~atom/src/atom/tooltip-manager');
export = alias;
}

// Generated by typings
// Source: src/atom/notification-manager.d.ts
declare module '~atom/src/atom/notification-manager' {
import EventKit = require('~atom~event-kit');
import Notification = require('~atom/src/atom/notification');

class NotificationManager {
  onDidAddNotification(callback: (notification: Notification) => void): EventKit.Disposable;
  addSuccess(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  addInfo(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  addWarning(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  addError(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  addFatalError(message: string, options?: {
    detail?: string;
    dismissable?: boolean;
    icon?: string;
  }): void;
  getNotifications(): Notification[];
}

export = NotificationManager;
}
declare module 'atom/src/atom/notification-manager' {
import alias = require('~atom/src/atom/notification-manager');
export = alias;
}

// Generated by typings
// Source: src/atom/project.d.ts
declare module '~atom/src/atom/project' {
import EventKit = require('~atom~event-kit');
import PathWatcher = require('~atom~pathwatcher');

import GitRepository = require('~atom/src/atom/git-repository');

class Project {
  // Event Subscription
  onDidChangePaths(callback: (projectPaths: string[]) => void): EventKit.Disposable;

  // Accessing the git repository
  /**
   * Will be removed in 2.0
   */
  getRepositories(): GitRepository[];
  repositoryForDirectory(directory: PathWatcher.Directory): PromiseLike<GitRepository>; // Was Repository. Likely API mistake.
  getPaths(): string[];
  setPaths(projectPaths: string[]): void;
  addPath(projectPath: string): void;
  removePath(projectPath: string): void;
  getDirectories(): PathWatcher.Directory[];
  relativizePath(fullPath: string): { projectPath: string, relativePath: string }[];
  contains(pathToCheck: string): boolean;
}

export = Project;
}
declare module 'atom/src/atom/project' {
import alias = require('~atom/src/atom/project');
export = alias;
}

// Generated by typings
// Source: src/atom/package.d.ts
declare module '~atom/src/atom/package' {
import EventKit = require('~atom~event-kit');

interface Package {
  onDidDeactivate: EventKit.EventHandler;
  isCompatible(): boolean;
  rebuild(): PromiseLike<{
    code: any,
    stdout: any,
    stderr: any
  }>;
  getBuildFailureOutput(): string;
}

export = Package;
}
declare module 'atom/src/atom/package' {
import alias = require('~atom/src/atom/package');
export = alias;
}

// Generated by typings
// Source: src/atom/package-manager.d.ts
declare module '~atom/src/atom/package-manager' {
import EventKit = require('~atom~event-kit');
import Package = require('~atom/src/atom/package');

class PackageManager {
  onDidLoadInitialPackages: EventKit.EventHandler;
  onDidActivateInitialPackages: EventKit.EventHandler;
  onDidActivatePackage(callback: (activatedPackage: Package) => void): EventKit.Disposable;
  onDidDeactivatePackage(callback: (deactivatedPackage: Package) => void): EventKit.Disposable;
  onDidLoadPackage(callback: (loadedPackage: Package) => void): EventKit.Disposable;
  onDidUnloadPackage(callback: (unloadedPackage: Package) => void): EventKit.Disposable;
  getApmPath(): string;
  getPackageDirPaths(): string[];
  resolvePackagePath(name: string): string;
  isBundledPackage(name: string): boolean;
  enablePackage(name: string): Package;
  disablePackage(name: string): Package;
  isPackageDisabled(name: string): boolean;
  getActivePackages(): Package[];
  getActivePackage(name: string): Package;
  isPackageActive(name: string): boolean;
  getLoadedPackages(): Package[];
  getLoadedPackage(name: string): Package;
  isPackageLoaded(name: string): boolean;
  getAvailablePackagePaths(): string[];
  getAvailablePackageNames(): string[];
  getAvailablePackageMetadata(): string[];
}

export = PackageManager;
}
declare module 'atom/src/atom/package-manager' {
import alias = require('~atom/src/atom/package-manager');
export = alias;
}

// Generated by typings
// Source: src/atom/theme-manager.d.ts
declare module '~atom/src/atom/theme-manager' {
import EventKit = require('~atom~event-kit');

class ThemeManager {
  onDidChangeActiveThemes: EventKit.EventHandler;
  getLoadedThemeNames(): string[];
  getLoadedThemes(): any[];
  getActiveThemeNames(): string[];
  getActiveThemes(): any[];
  getEnabledThemeNames(): string[];
}

export = ThemeManager;
}
declare module 'atom/src/atom/theme-manager' {
import alias = require('~atom/src/atom/theme-manager');
export = alias;
}

// Generated by typings
// Source: src/atom/style-manager.d.ts
declare module '~atom/src/atom/style-manager' {
import EventKit = require('~atom~event-kit');

interface StyleElement extends HTMLStyleElement {
  sourcePath: string;
  context: string;
}

class StyleManager {
  observeStyleElements(callback: (styleElement: StyleElement) => void): EventKit.Disposable;
  onDidAddSytleElement(callback: (styleElement: StyleElement) => void): EventKit.Disposable;
  onDidRemoveSytleElement(callback: (styleElement: HTMLStyleElement) => void): EventKit.Disposable;
  onDidUpdateSytleElement(callback: (styleElement: StyleElement) => void): EventKit.Disposable;
  getStyleElements(): StyleElement[];
  getUserStyleSheetPath(): string;
}

export = StyleManager;
}
declare module 'atom/src/atom/style-manager' {
import alias = require('~atom/src/atom/style-manager');
export = alias;
}

// Generated by typings
// Source: src/atom/atom-environment.d.ts
declare module '~atom/src/atom/atom-environment' {
import EventKit = require('~atom~event-kit');
import KeymapManager = require('~atom~atom-keymap');
import FirstMate = require('~atom~first-mate');

import CommandRegistry = require('~atom/src/atom/command-registry');
import Config = require('~atom/src/atom/config');
import Clipboard = require('~atom/src/atom/clipboard');
import ContextMenuManager = require('~atom/src/atom/context-menu-manager');
import MenuManager = require('~atom/src/atom/menu-manager');
import TooltipManager = require('~atom/src/atom/tooltip-manager');
import NotificationManager = require('~atom/src/atom/notification-manager');
import Project = require('~atom/src/atom/project');
import PackageManager = require('~atom/src/atom/package-manager');
import ThemeManager = require('~atom/src/atom/theme-manager');
import StyleManager = require('~atom/src/atom/style-manager');
import DeserializerManager = require('~atom/src/atom/deserializer-manager');
import ViewRegistry = require('~atom/src/atom/view-registry');
import Workspace = require('~atom/src/atom/workspace');

interface AtomEnvironment {
  commands: CommandRegistry;
  config: Config;
  clipboard: Clipboard;
  contextMenu: ContextMenuManager;
  menu: MenuManager;
  keymaps: KeymapManager;
  tooltips: TooltipManager;
  notifications: NotificationManager;
  project: Project;
  grammars: FirstMate.GrammarRegistry;
  packages: PackageManager;
  themes: ThemeManager;
  styles: StyleManager;
  deserializers: DeserializerManager;
  views: ViewRegistry;
  workspace: Workspace;
  // Extended Methods
  onDidBeep: EventKit.EventHandler;
  onWillThrowError(callback: (event: {
    originalError: Object;
    message: string;
    url: string;
    line: number;
    column: number;
    preventDefault(): void;
  }) => void): EventKit.Disposable;
  onDidThrowError(callback: (event: {
    originalError: Object;
    message: string;
    url: string;
    line: number;
    column: number;
  }) => void): EventKit.Disposable;
}

export = AtomEnvironment;
}
declare module 'atom/src/atom/atom-environment' {
import alias = require('~atom/src/atom/atom-environment');
export = alias;
}

// Generated by typings
// Source: src/atom/deserializer-manager.d.ts
declare module '~atom/src/atom/deserializer-manager' {
import AtomEnvironment = require('~atom/src/atom/atom-environment');

class DeserializerManager {
  add(deserializers: { name: string, deserialize: (serializedState: any, atom: AtomEnvironment) => any }): void;
  deserialize(state: Object): void;
}

export = DeserializerManager;
}
declare module 'atom/src/atom/deserializer-manager' {
import alias = require('~atom/src/atom/deserializer-manager');
export = alias;
}

// Generated by typings
// Source: src/atom/view-registry.d.ts
declare module '~atom/src/atom/view-registry' {
import EventKit = require('~atom~event-kit');

class ViewRegistry {
  addViewProvider(createView: () => HTMLElement): EventKit.Disposable;
  addViewProvider(modelConstructor: Function, createView: () => HTMLElement): EventKit.Disposable;
  getView(object: Object): any; // DOM element
}

export = ViewRegistry;
}
declare module 'atom/src/atom/view-registry' {
import alias = require('~atom/src/atom/view-registry');
export = alias;
}

// Generated by typings
// Source: src/atom/workspace.d.ts
declare module '~atom/src/atom/workspace' {
interface Workspace {
  addModalPanel(option: any);
}

export = Workspace;
}
declare module 'atom/src/atom/workspace' {
import alias = require('~atom/src/atom/workspace');
export = alias;
}

// Generated by typings
// Source: src/atom/task.d.ts
declare module '~atom/src/atom/task' {
class Task {
  // Methods
  static once(taskPath: string, args: any[]): Task;
  constructor(taskPath: string);
  start(args: any[], callback?: Function): void;
  send(message: any): void;
  on(eventName: string, callback: Function): void;
  once(taskPath: string, args: any[]): Task;
  terminate(): void;
}
export = Task;
}
declare module 'atom/src/atom/task' {
import alias = require('~atom/src/atom/task');
export = alias;
}

// Generated by typings
// Source: src/atom/cursor.d.ts
declare module '~atom/src/atom/cursor' {
import EventKit = require('~atom~event-kit');
import TextBuffer = require('~atom~text-buffer');
import TextEditorMarker = require('~atom/src/atom/text-editor-marker');
import CursorChangeEventHandler = require('~atom/src/atom/cursor-change-event-handler');
import ScopeDescriptor = require('~atom/src/atom/scope-descriptor');

interface Cursor {
  onDidChangePosition: CursorChangeEventHandler;
  onDidDestroy: (callback: () => void) => EventKit.Disposable;
  onDidChangeVisibility(callback: (visibility: boolean) => void): EventKit.Disposable;
  setScreenPosition(screenPosition: number[], options?: { autoscroll: boolean }): void;
  getScreenPosition(): TextBuffer.Point;
  setBufferPosition(bufferPosition: number[], options?: { autoscroll: boolean }): void;
  getBufferPosition(): TextBuffer.Point;
  getScreenRow(): number;
  getScreenColumn(): number;
  getBufferRow(): number;
  getBufferColumn(): number;
  getCurrentBufferLine(): number;
  isAtBeginningOfLine(): boolean;
  isAtEndOfLine(): boolean;
  getMarker(): TextEditorMarker;
  isSurroundedByWhitespace(): boolean;
  isBetweenWOrdAndNonWord(): boolean;
  isInsideWord(option?: { wordRegex: RegExp }): boolean;
  getIndentLevel(): number;
  getScopeDescriptor(): ScopeDescriptor;
  hasPrecedingCharactersOnLine(): boolean;
  isLastCursor(): boolean;
  moveUp(rowCount?: number, options?: { moveToEndOfSelection }): void;
  moveDown(rowCount?: number, options?: { moveToEndOfSelection }): void;
  moveLeft(columnCount?: number, options?: { moveToEndOfSelection }): void;
  moveRight(columnCount?: number, options?: { moveToEndOfSelection }): void;
  moveToTop(): void;
  moveToBottom(): void;
  moveToBeginningOfScreenLine(): void;
  moveToBeginningOfLine(): void;
  moveToFirstCharacterOfLine(): void;
  moveToEndOfScreenLine(): void;
  moveToEndOfLine(): void;
  moveToBeginningOfWord(): void;
  moveToEndOfWord(): void;
  moveToBeginningOfNextWord(): void;
  moveToPreviousWordBoundary(): void;
  moveToNextWordBoundary(): void;
  moveToPreviousSubwordBoundary(): void;
  moveToNextSubwordBoundary(): void;
  skipLeadingWhitespace(): void;
  moveToBeginningOfNextParagraph(): void;
  moveToBeginningOfPreviousParagraph(): void;
  getPreviousWordBoundaryBufferPosition(options?: { wordRegex: RegExp }): any;
  getNextWordBoundaryBufferPosition(options?: { wordRegex: RegExp }): any;
  getBeginningOfCurrentWordBufferPosition(options?: {
    wordRegex: RegExp,
    includeNonWordCharacters: boolean,
    allowPrevious: boolean
  }): Range;
  getEndOfCurrentWordBufferPosition(options?: {
    wordRegex: RegExp,
    includeNonWordCharacters: boolean
  }): Range;
  getBeginningOfNextWordBufferPosition(options?: { wordRegex: RegExp }): Range;
  getCurrentWordBufferRange(options?: { wordRegex: RegExp }): Range;
  getCurrentLineBufferRange(options?: { includeNewLine: boolean }): Range;
  getCurrentParagraphBufferRange(): Range;
  getCurrentWordPrefix(): string;
  setVisible(): void;
  isVisible(): boolean;
  compare(otherCursor: Cursor): number;
  clearAutoscroll(): void;
  clearSelection(): void;
  wordRegExp(options?: { includeNonWordCharacters?: boolean }): RegExp;
  subwordRegExp(options?: { backwards?: boolean }): RegExp;
}
export = Cursor;
}
declare module 'atom/src/atom/cursor' {
import alias = require('~atom/src/atom/cursor');
export = alias;
}

// Generated by typings
// Source: src/atom/decoration.d.ts
declare module '~atom/src/atom/decoration' {
import EventKit = require('~atom~event-kit');

class Decoration {
  destroy(): void;
  onDidChangeProperties(callback: (event: {
    oldProperties: Object;
    newProperties: Object;
  }) => void): EventKit.Disposable;
  onDidDestroy: (callback: () => void) => EventKit.Disposable;
  getId(): any;
  getMarker(): any; // Marker;
  getProperties(): Object;
  setProperties(newProperties: Object): void;
}
export = Decoration;
}
declare module 'atom/src/atom/decoration' {
import alias = require('~atom/src/atom/decoration');
export = alias;
}

// Generated by typings
// Source: src/atom/gutter.d.ts
declare module '~atom/src/atom/gutter' {
import EventKit = require('~atom~event-kit');

import TextEditorMarker = require('~atom/src/atom/text-editor-marker');
import Decoration = require('~atom/src/atom/decoration');

interface Gutter {
  // Gutter Destruction
  destroy(): void;

  // Event Subscription
  onDidChangeVisible(callback: (gutter: Gutter) => void): EventKit.Disposable;
  onDidDestroy: (callback: () => void) => EventKit.Disposable;

  // Visibility
  hide(): void;
  show(): void;
  isVisible(): boolean;
  decorateMarker(marker: TextEditorMarker, decorationParams: { type: 'line-number' | 'gutter' }): Decoration;
}
export = Gutter;
}
declare module 'atom/src/atom/gutter' {
import alias = require('~atom/src/atom/gutter');
export = alias;
}

// Generated by typings
// Source: src/atom/text-editor-marker.d.ts
declare module '~atom/src/atom/text-editor-marker' {
import EventKit = require('~atom~event-kit');
import TextBuffer = require('~atom~text-buffer');

class TextEditorMarker {
  destroy(): void;
  copy(properties?: Object): TextEditorMarker;
  onDidChange(callback: (event: {
    oldHeadBufferPosition: TextBuffer.Point;
    newHeadBufferPosition: TextBuffer.Point;
    oldTailBufferPosition: TextBuffer.Point;
    newTailBufferPosition: TextBuffer.Point;
    oldHeadScreenPosition: TextBuffer.Point;
    newHeadScreenPosition: TextBuffer.Point;
    oldTailScreenPosition: TextBuffer.Point;
    newTailScreenPosition: TextBuffer.Point;
    wasValid: boolean;
    isValid: boolean;
    hadTail: boolean;
    hasTail: boolean;
    oldProperties: Object;
    newProperties: Object;
    textChanged: boolean;
  }) => void): EventKit.Disposable;
  onDidDestroy: (callback: () => void) => EventKit.Disposable;
  isValid(): boolean;
  isDestroyed(): boolean;
  isReversed(): boolean;
  getInvalidationStrategy(): string;
  getProperties(): Object;
  setProperties(properties: Object): void;
  isEqual(other: TextEditorMarker): boolean;
  compare(other: TextEditorMarker): number;
  getBufferRange(): TextBuffer.Range;
  setBufferRange(bufferRange: TextBuffer.Range, properties?: { reversed: boolean }): void;
  getScreenRange(): TextBuffer.Range;
  setScreenRange(bufferRange: TextBuffer.Range, properties?: { reversed: boolean }): void;
  getStartBufferPosition(): TextBuffer.Point;
  getStartScreenPosition(): TextBuffer.Point;
  getEndBufferPosition(): TextBuffer.Point;
  getEndScreenPosition(): TextBuffer.Point;

  // Extended Methods
  getHeadBufferPosition(): TextBuffer.Point;
  getHeadBufferPosition(bufferPosition: TextBuffer.Point, properties?: Object): void;
  getHeadScreenPosition(): TextBuffer.Point;
  getHeadScreenPosition(screenPosition: TextBuffer.Point, properties?: Object): void;
  getTailBufferPosition(): TextBuffer.Point;
  getTailBufferPosition(bufferPosition: TextBuffer.Point, properties?: Object): void;
  getTailScreenPosition(): TextBuffer.Point;
  getTailScreenPosition(screenPosition: TextBuffer.Point, properties?: Object): void;
  hasTail(): boolean;
  plantTail(properties?: Object): void;
  clearTail(properties?: Object): void;
}

export = TextEditorMarker;
}
declare module 'atom/src/atom/text-editor-marker' {
import alias = require('~atom/src/atom/text-editor-marker');
export = alias;
}

// Generated by typings
// Source: src/atom/text-editor-marker-layer.d.ts
declare module '~atom/src/atom/text-editor-marker-layer' {
import EventKit = require('~atom~event-kit');
import TextBuffer = require('~atom~text-buffer');

import TextEditorMarker = require('~atom/src/atom/text-editor-marker');

class TextEditorMarkerLayer {
  // Lifecycle
  destroy(): void;

  // Querying
  getMarker(): TextEditorMarker;
  getMarkers(): TextEditorMarker[];
  getMarkerCount(): number;
  findMarkers(properties: {
    startBufferRow: number,
    endBufferRow: number,
    containsBufferRange: TextBuffer.Range | TextBuffer.Point[],
    containsBufferPosition: TextBuffer.Point | number[]
  }): TextEditorMarker[];

  // Marker creation
  markBufferRange(range: TextBuffer.Range | TextBuffer.Point[], properties: {
    maintainHistory?: boolean,
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markScreenRange(range: TextBuffer.Range, properties: {
    maintainHistory?: boolean,
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markBufferPosition(position: TextBuffer.Point | number[], options?: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markScreenPosition(position: TextBuffer.Point | number[], options?: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;

  // Event Subscription
  onDidUpdate: EventKit.EventHandler;
  onDidCreateMarker(callback: (marker: TextEditorMarker) => void): EventKit.Disposable;
  onDidDestroy: EventKit.EventHandler;
}

export = TextEditorMarkerLayer;
}
declare module 'atom/src/atom/text-editor-marker-layer' {
import alias = require('~atom/src/atom/text-editor-marker-layer');
export = alias;
}

// Generated by typings
// Source: src/atom/cursor-change-event-handler.d.ts
declare module '~atom/src/atom/cursor-change-event-handler' {
import EventKit = require('~atom~event-kit');
import TextBuffer = require('~atom~text-buffer');
import Cursor = require('~atom/src/atom/cursor');

interface CursorChangeEventHandler {
  (callback: (event: {
    oldBufferPosition: TextBuffer.Point,
    oldScrrenPosition: TextBuffer.Point,
    newBufferPosition: TextBuffer.Point,
    newScrrenPosition: TextBuffer.Point,
    textChanged: boolean,
    cursor: Cursor
  }) => void): EventKit.Disposable;
}
export = CursorChangeEventHandler;
}
declare module 'atom/src/atom/cursor-change-event-handler' {
import alias = require('~atom/src/atom/cursor-change-event-handler');
export = alias;
}

// Generated by typings
// Source: src/atom/selection.d.ts
declare module '~atom/src/atom/selection' {
import EventKit = require('~atom~event-kit');
import TextBuffer = require('~atom~text-buffer');

class Selection {
  onDidChangeRange(callback: (event: {
    oldBufferRange: TextBuffer.Range;
    oldScreenRange: TextBuffer.Range;
    newBufferRange: TextBuffer.Range;
    newScreenRange: TextBuffer.Range;
    selection: Selection
  }) => void): EventKit.Disposable;
  onDidDestroy: EventKit.EventHandler;
  getScreenRange(): TextBuffer.Range;
  setScreenRange(screenRange: Range, options?: {
    preserveFolds?: boolean,
    autoScroll?: boolean
  }): void;
  getbufferRange(): TextBuffer.Range;
  setbufferRange(bufferRange: Range, options?: {
    preserveFolds?: boolean,
    autoScroll?: boolean
  }): void;
  getBufferRowRange(): any;
  isEmpty(): boolean;
  isReversed(): boolean;
  isSingleScreenLine(): boolean;
  getText(): string;
  intersectsBufferRange(bufferRange: Range): boolean;
  intersectsWith(otherSelection: Selection): boolean;
  clear(options?: { autoScroll: boolean }): void;
  selectToScreenPosition(position: TextBuffer.Point): void;
  selectToBufferPosition(position: TextBuffer.Point): void;
  selectRight(columnCount?: number): void;
  selectLeft(columnCount?: number): void;
  selectUp(rowCount?: number): void;
  selectDown(rowCount?: number): void;
  selectToTop(): void;
  selectToBottom(): void;
  selectAll(): void;
  selectToBeginningOfLine(): void;
  selectToFirstCharactorOfLine(): void;
  selectToEndOfLine(): void;
  selectToEndOfBufferLine(): void;
  selectToBeginningOfWord(): void;
  selectToEndOfWord(): void;
  selectToBeginningOfNextWord(): void;
  selectToPreviousWordBoundary(): void;
  selectToNextWordBoundary(): void;
  selectToPreviousSubwordBoundary(): void;
  selectToNextSubwordBoundary(): void;
  selectToBeginningOfNextParagraph(): void;
  selectToBeginningOfPreviousParagraph(): void;
  selectWord(): void;
  expandOverWord(): void;
  selectLine(row: number): void;
  expandOverLine(): void;
  insertText(text: string, options?: {
    select: boolean;
    autoIndent: boolean;
    autoIndentNewLine: boolean;
    autoDecreaseIndent: boolean;
    normalizeLineEndings?: boolean;
    undo: 'skip'
  }): void;
  backspace(): void;
  deleteToPreviousWordBoundary(): void;
  deleteToNextWordBoundary(): void;
  deleteToBeginningOfWord(): void;
  deleteToBeginningOfLine(): void;
  delete(): void;
  deleteToEndOfLine(): void;
  deleteToEndOfWord(): void;
  deleteToBeginningOfSubword(): void;
  deleteToEndOfSubword(): void;
  deleteLine(): void;
  joinLines(): void;
  outdentSelectedRows(): void;
  autoIndentSelectedRows(): void;
  toggleLineComments(): void;
  cutToEndOfLine(): void;
  cutToEndOfBufferLine(): void;
  cut(maintainClipboard: boolean, fullLine: boolean): void;
  copy(maintainClipboard: boolean, fullLine: boolean): void;
  fold(): void;
  indentSelectedRows(): void;
  addSelectionBelow(): void;
  addSelectionAbove(): void;
  merge(otherSelection: Selection, options?: {
    preserveFolds?: boolean,
    autoScroll?: boolean
  }): void;
  compare(otherSelection: Selection): number;
}
export = Selection;
}
declare module 'atom/src/atom/selection' {
import alias = require('~atom/src/atom/selection');
export = alias;
}

// Generated by typings
// Source: src/atom/selection-change-event-handler.d.ts
declare module '~atom/src/atom/selection-change-event-handler' {
import EventKit = require('~atom~event-kit');
import TextBuffer = require('~atom~text-buffer');
import Selection = require('~atom/src/atom/selection');

interface SelectionChangeEventHandler {
  (callback: (event: {
    oldBufferRange: TextBuffer.Range,
    oldScreenRange: TextBuffer.Range,
    newBufferRange: TextBuffer.Range,
    newScreenRange: TextBuffer.Range,
    selection: Selection
  }) => void): EventKit.Disposable;
}

export = SelectionChangeEventHandler;
}
declare module 'atom/src/atom/selection-change-event-handler' {
import alias = require('~atom/src/atom/selection-change-event-handler');
export = alias;
}

// Generated by typings
// Source: src/atom/clip-screen-position-option.d.ts
declare module '~atom/src/atom/clip-screen-position-option' {
interface ClipScreenPositionOption {
  wrapBeyondNewlines?: boolean;
  wrapAtSoftNewlines?: boolean;
  screenLine?: boolean;
}
export = ClipScreenPositionOption;
}
declare module 'atom/src/atom/clip-screen-position-option' {
import alias = require('~atom/src/atom/clip-screen-position-option');
export = alias;
}

// Generated by typings
// Source: src/atom/text-editor.d.ts
declare module '~atom/src/atom/text-editor' {
import EventKit = require('~atom~event-kit');
import TextBuffer = require('~atom~text-buffer');
import FirstMate = require('~atom~first-mate');

import Cursor = require('~atom/src/atom/cursor');
import Decoration = require('~atom/src/atom/decoration');
import Gutter = require('~atom/src/atom/gutter');
import TextEditorMarker = require('~atom/src/atom/text-editor-marker');
import TextEditorMarkerLayer = require('~atom/src/atom/text-editor-marker-layer');
import ScopeDescriptor = require('~atom/src/atom/scope-descriptor');

import CursorChangeEventHandler = require('~atom/src/atom/cursor-change-event-handler');
import SelectionChangeEventHandler = require('~atom/src/atom/selection-change-event-handler');
import ClipScreenPositionOption = require('~atom/src/atom/clip-screen-position-option');

class TextEditor {
  onDidChangeTitle: (callback: () => void) => EventKit.Disposable;
  onDidChangePath: (callback: () => void) => EventKit.Disposable;
  onDidChange: (callback: () => void) => EventKit.Disposable;
  onDidStopChanging: (callback: () => void) => EventKit.Disposable;
  onDidChangeCursorPosition: CursorChangeEventHandler;
  onDidChangeSelectionRange: SelectionChangeEventHandler;
  onDidSave(callback: (event: { path: string }) => void): EventKit.Disposable;
  onDidDestroy: (callback: () => void) => EventKit.Disposable;
  getBuffer(): TextBuffer;
  observeGutters(callback: (gutter: Gutter) => void): EventKit.Disposable;
  onDidAddGutter(callback: (gutter: Gutter) => void): EventKit.Disposable;
  onDidRemoveGutter(callback: (name: string) => void): EventKit.Disposable;

  // Extended Methods
  onDidChangeSoftWrapped: (callback: () => void) => EventKit.Disposable;
  onDidChangeEncoding: (callback: () => void) => EventKit.Disposable;
  observeGrammar: FirstMate.GrammarEventHandler;
  onDidChangeGrammar: FirstMate.GrammarEventHandler;
  onDidChangeModified: (callback: () => void) => EventKit.Disposable;
  onDidConflict: (callback: () => void) => EventKit.Disposable;
  onWillInsertText(callback: (event: { text: string, cancel(): void }) => void): EventKit.Disposable;
  onDidInsertText(callback: (event: { text: string }) => void): EventKit.Disposable;
  observeCursors(callback: (cursor: Cursor) => void): EventKit.Disposable;
  onDidAddCursor(callback: (cursor: Cursor) => void): EventKit.Disposable;
  onDidRemoveCursor(callback: (cursor: Cursor) => void): EventKit.Disposable;
  observeSelections(callback: (selection: Selection) => void): EventKit.Disposable;
  onDidAddSelection(callback: (selection: Selection) => void): EventKit.Disposable;
  onDidRemoveSelection(callback: (selection: Selection) => void): EventKit.Disposable;
  observeDecorations(callback: (decoration: Decoration) => void): EventKit.Disposable;
  onDidAddDecoration(callback: (decoration: Decoration) => void): EventKit.Disposable;
  onDidRemoveDecoration(callback: (decoration: Decoration) => void): EventKit.Disposable;
  onDidChangePlaceholderText(callback: (placeholderText: string) => void): EventKit.Disposable;

  // File Details
  getTitle(): string;
  getLongTitle(): string;
  getPath(): string;
  isModified(): boolean;
  isEmpty(): boolean

  // Extended Methods
  getEncoding(): string;
  setEncoding(encoding): void;

  // File Operations
  save(): void;
  saveAs(filePath: string): void;

  // Reading Text
  getText(): string;
  getTextInBufferRange(range: TextBuffer.Range): string;
  getLineCount(): number;
  getScreenLineCount(): number;
  getLastBufferRow(): number;
  getLastScreenRow(): number;
  lineTextForBufferRow(bufferRow: number): string;
  lineTextForScreenRow(screenRow: number): string;
  getCurrentParagraphBufferRange(): TextBuffer.Range;

  // Mutating Text
  setText(text: string): void
  setTextInBufferRange(range: TextBuffer.Range, text: string, options?: {
    normalizeLineEndings?: boolean,
    undo?: 'skip'
  }): TextBuffer.Range;
  insertText(text: string, options?: {
    select: boolean;
    autoIndent: boolean;
    autoIndentNewLine: boolean;
    autoDecreaseIndent: boolean;
    normalizeLineEndings?: boolean;
    undo: 'skip'
  }): TextBuffer.Range | boolean;
  insertNewline(): void;
  delete(): void;
  backspace(): void;

  // Extended Methods
  mutateSelectedText(fn: (selection: Selection, index: number) => void): void;
  transpose(): void;
  upperCase(): void;
  lowerCase(): void;
  toggleLineCommentsInSelection(): void;
  insertNewlineBelow(): void;
  insertNewlineAbove(): void;
  deleteToBeginningOfWord(): void;
  deleteToPreviousWordBoundary(): void;
  deleteToNextWordBoundary(): void;
  deleteToBeginningOfSubword(): void;
  deleteToEndOfSubword(): void;
  deleteToBeginningOfLine(): void;
  deleteToEndOfLine(): void;
  deleteToEndOfWord(): void;
  deleteLine(): void;

  // History
  undo(): void;
  redo(): void;

  // Extended Methods
  transact(fn: Function): void;
  transact(groupingInterval: number, fn: Function): void;
  abortTransaction(): void;
  createCheckpoint(): any;
  revertToCheckpoint(): boolean;
  groupChangesSinceCheckpoint(): boolean;

  // TextEditor Coordinates
  screenPositionForBufferPosition(bufferPosition: TextBuffer.Point | number[], options?: ClipScreenPositionOption): TextBuffer.Point;
  bufferPositionForScreenPosition(bufferPosition: TextBuffer.Point | number[], options?: ClipScreenPositionOption): TextBuffer.Point;
  screenRangeForBufferRange(bufferRange: TextBuffer.Range): TextBuffer.Range;
  bufferRangeForScreenRange(screenRange: TextBuffer.Range): TextBuffer.Range;

  // Extended Methods
  clipBufferPosition(bufferPosition: TextBuffer.Point): TextBuffer.Point;
  clipBufferRange(range: TextBuffer.Range): TextBuffer.Range;
  clipScreenPosition(screenPosition: TextBuffer.Point, options?: ClipScreenPositionOption): TextBuffer.Point;
  clipScreenRange(range: TextBuffer.Range, options?: ClipScreenPositionOption): TextBuffer.Range;

  // Decorations
  decorateMarker(marker: TextEditorMarker, decorationParams: {
    type: 'line' | 'line-number' | 'highlight' | 'overlay' | 'gutter' | 'block',
    class: string,
    item?: HTMLElement | Object,
    onlyHead?: boolean,
    onlyEmpty?: boolean,
    onlyNonEmpty?: boolean,
    position?: 'head' | 'tail' | 'before' | 'after'
  }): Decoration;
  decorateMarkerLayer(markerLayer: TextEditorMarkerLayer | TextBuffer.MarkerLayer, decorationParams: {
    type: 'line' | 'line-number' | 'highlight' | 'block',
    class: string,
    item?: HTMLElement | Object,
    onlyHead?: boolean,
    onlyEmpty?: boolean,
    onlyNonEmpty?: boolean,
    position?: 'head' | 'tail' | 'before' | 'after'
  }): Decoration;

  // Extended Methods
  getDecorations(propertyFilter?: Object): Decoration[];
  getLineDecorations(propertyFilter?: Object): Decoration[];
  getLineNumberDecorations(propertyFilter?: Object): Decoration[];
  getHighlightDecorations(propertyFilter?: Object): Decoration[];
  getOverlayDecorations(propertyFilter?: Object): Decoration[];

  // Markers
  markBufferRange(range: TextBuffer.Range | TextBuffer.Point[], properties: {
    maintainHistory?: boolean,
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markScreenRange(range: TextBuffer.Range, properties: {
    maintainHistory?: boolean,
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markBufferPosition(position: TextBuffer.Point | number[], options?: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  markScreenPosition(position: TextBuffer.Point | number[], options?: {
    reversed?: boolean,
    persistent?: boolean,
    invalidate?: 'never' | 'surround' | 'overlap' | 'inside' | 'touch'
  }): TextEditorMarker;
  findMarkers(properties: {
    startBufferRow: number,
    endBufferRow: number,
    containsBufferRange: TextBuffer.Range | TextBuffer.Point[],
    containsBufferPosition: TextBuffer.Point | number[]
  }): TextEditorMarker[];
  getMarkerLayer(id: any): TextEditorMarkerLayer;
  getDefaultMarkerLayer(): TextEditorMarkerLayer;

  // Extended Methods
  getMarker(id: number): TextEditorMarker;
  getMarkers(): TextEditorMarker[];
  getMarkerCount(): number;
  addMarkerLayer(options: { maintainHistory?: boolean }): TextEditorMarkerLayer;

  // Cursors
  getCursorBufferPosition(): TextBuffer.Point;
  getCursorBufferPositions(): TextBuffer.Point[];
  setCursorBufferPosition(position: TextBuffer.Point | number[], options?: { autoscroll?: boolean }): void
  getCursorAtScreenPosition(position: TextBuffer.Point | number[]): Cursor;
  getCursorScreenPosition(): TextBuffer.Point;
  getCursorScreenPositions(): TextBuffer.Point[];
  setCursorScreenPosition(position: TextBuffer.Point | number[], options?: { autoscroll?: boolean }): void;
  addCursorAtBufferPosition(bufferPosition: TextBuffer.Point): Cursor;
  addCursorAtScreenPosition(screenPosition: TextBuffer.Point): Cursor;
  hasMultipleCursors(): boolean;
  moveUp(lineCount?: number): void;
  moveDown(lineCount?: number): void;
  moveLeft(columnCount?: number): void;
  moveRight(columnCount?: number): void;
  moveToBeginningOfLine(): void;
  moveToBeginningOfScreenLine(): void;
  moveToFirstCharacterOfLine(): void;
  moveToEndOfLine(): void;
  moveToEndOfScreenLine(): void;
  moveToBeginningOfWord(): void;
  moveToEndOfWord(): void;

  // Extended Methods
  moveToTop(): void;
  moveToBottom(): void;
  moveToBeginningOfNextWord(): void;
  moveToPreviousWordBoundary(): void;
  moveToNextWordBoundary(): void;
  moveToPreviousSubwordBoundary(): void;
  moveToNextSubwordBoundary(): void;
  moveToBeginningOfNextParagraph(): void;
  moveToBeginningOfPreviousParagraph(): void;
  getLastCursor(): Cursor;
  getWordUnderCursor(options?: { wordRegex?: RegExp, includeNonWordCharacters: boolean, allowPrevious: boolean }): string;
  getCursors(): Cursor[];
  getCursorsOrderedByBufferPosition(): Cursor[];

  // Selections
  getSelectedText(): string;
  getSelectedBufferRange(): TextBuffer.Range;
  getSelectedBufferRanges(): TextBuffer.Range[];
  setSelectedBufferRange(bufferRange: TextBuffer.Range | TextBuffer.Point[], options?: {
    reversed: boolean,
    preserveFolds: boolean
  }): void;
  setSelectedBufferRanges(bufferRanges: TextBuffer.Range[] | TextBuffer.Point[][], options?: {
    reversed: boolean,
    preserveFolds: boolean
  }): void;
  getSelectedScreenRange(): TextBuffer.Range;
  getSelectedScreenRanges(): TextBuffer.Range[];
  setSelectedScreenRange(screenRange: TextBuffer.Range | TextBuffer.Point[], options?: { reversed: boolean }): void;
  setSelectedScreenRanges(screenRangee: TextBuffer.Range[] | TextBuffer.Point[][], options?: { reversed: boolean }): void;
  addSelectionForBufferRange(bufferRange, options?: { reversed: boolean }): Selection;
  addSelectionForScreenRange(screenRange, options?: { reversed: boolean }): Selection;
  selectToBufferPosition(position: TextBuffer.Point): void;
  selectToScreenPosition(position: TextBuffer.Point): void;
  selectUp(rowCount: number): void;
  selectDown(rowCount: number): void;
  selectLeft(columnCount: number): void;
  selectRight(columnCount: number): void;
  selectToTop(): void;
  selectToBottom(): void;
  selectAll(): void;
  selectToBeginningOfLine(): void;
  selectToFirstCharacterOfLine(): void;
  selectToEndOfLine(): void;
  selectToBeginningOfWord(): void;
  selectToEndOfWord(): void;
  selectLinesContainingCursors(): void;
  selectWordsContainingCursors(): void;

  // Extended Methods
  selectToPreviousSubwordBoundary(): void;
  selectToNextSubwordBoundary(): void;
  selectToPreviousWordBoundary(): void;
  selectToNextWordBoundary(): void;
  selectToBeginningOfNextWord(): void;
  selectToBeginningOfNextParagraph(): void;
  selectToBeginningOfPreviousParagraph(): void;
  selectMarker(marker: TextEditorMarker): void;
  getLastSelection(): Selection;
  getSelections(): Selection[];
  getSelectionsOrderedByBufferPosition(): Selection[];
  selectionIntersectsBufferRange(bufferRange: TextBuffer.Range | TextBuffer.Point[]): boolean;

  // Searching and Replacing
  scan: TextBuffer.ScanFunction;
  scanInBufferRange: TextBuffer.ScanInRangeFunction;
  backwardsScanInBufferRange: TextBuffer.ScanInRangeFunction;

  // Tab Behavior
  getSoftTabs(): boolean;
  setSoftTabs(softTabs: boolean): void;
  toggleSoftTabs(): void;
  getTabLength(): number;
  setTabLength(tabLength: number): void;

  // Extended Methods
  usesSoftTabs(): boolean;
  getTabText(): string;

  // Soft Wrap Behavior
  isSoftWrapped(): boolean;
  setSoftWrapped(softWrapped: boolean): void;
  toggleSoftWrapped(): void;
  getSoftWrapColumn(): number;

  // Indentation
  indentationForBufferRow(bufferRow: number): number;
  setIndentationForBufferRow(bufferRow: number, newLevel: number, options?: { preserveLeadingWhitespace: boolean }): void;

  // Extended Methods
  indentSelectedRows(): void;
  outdentSelectedRows(): void;
  indentLevelForLine(line: string): number;
  autoIndentSelectedRows(): void;

  // Grammars
  getGrammar(): FirstMate.Grammar;
  setGrammar(grammar: FirstMate.Grammar): void;

  // Managing Syntax Scopes
  getRootScopeDescriptor(): ScopeDescriptor;
  scopeDescriptorForBufferPosition(bufferPosition: TextBuffer.Point | number[]): ScopeDescriptor;

  // Extended Methods
  bufferRangeForScopeAtCursor(scopeSelector: string): TextBuffer.Range;
  isBufferRowCommented(): boolean;

  // Clipboard Operations
  copySelectedText(): void;
  cutSelectedText(): void;
  pasteText(options?: {
    select: boolean;
    autoIndent: boolean;
    autoIndentNewLine: boolean;
    autoDecreaseIndent: boolean;
    normalizeLineEndings?: boolean;
    undo: 'skip'
  }): void;
  cutToEndOfLine(): void;
  cutToEndOfBufferLine(): void;

  // Folds
  foldCurrentRow(): void;
  unfoldCurrentRow(): void;
  foldBufferRow(bufferRow: number): void;
  unfoldBufferRow(bufferRow: number): void;

  //  Extended Methods
  foldSelectedLines(): void;
  foldAll(): void;
  unfoldAll(): void;
  foldAllAtIndentLevel(level: number): void;
  isFoldableAtBufferRow(bufferRow: number): boolean;
  isFoldableAtScreenRow(bufferRow: number): boolean;
  toggleFoldAtBufferRow(): void;
  isFoldedAtCursorRow(): boolean;
  isFoldedAtBufferRow(bufferRow: number): boolean;
  isFoldedAtScreenRow(screenRow: number): boolean;

  // Gutters
  addGutter(options: { name: string, priority?: number, visible?: boolean }): Gutter;
  getGutters(): Gutter[];
  gutterWithName(name: string): Gutter;

  // Scrolling the TextEditor
  scrollToCursorPosition(options?: { center?: boolean }): void;
  scrollToBufferPosition(bufferPosition: TextBuffer.Point | number[] | { row: number, column: number }, options?: { center?: boolean }): void;
  scrollToScreenPosition(screenPosition: TextBuffer.Point | number[] | { row: number, column: number }, options?: { center?: boolean }): void;

  // TextEditor Rendering
  getPlaceholderText(): string
  setPlaceholderText(placeholderText: string): void;
}


export = TextEditor;
}
declare module 'atom/src/atom/text-editor' {
import alias = require('~atom/src/atom/text-editor');
export = alias;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-pathwatcher/a40728b979faadbd2a9f9a3fe472d9350a06bf81/lib/file.d.ts
declare module '~atom~pathwatcher/lib/file' {

import Directory = require('~atom~pathwatcher/lib/directory');

class File {
  constructor(filePath: string, symlink?: boolean);
  create(): PromiseLike<boolean>;
  onDidChange(callback: () => void): void;
  onDidRename(callback: () => void): void;
  onDidDelete(callback: () => void): void;
  onWillThrowWatchError(callback: (errorObject: {
    error: Object;
    handle(): void
  }) => void): void;
  isFile(): boolean;
  isDirectory(): boolean;
  isSymbolicLink(): boolean;
  exists(): PromiseLike<boolean>;
  existsSync(): boolean;
  getDigest(): PromiseLike<string>;
  getDigestSync(): string;
  setEncoding(encoding: string): void;
  getEncoding(): string;
  getPath(): string;
  getRealPathSync(): string;
  getRealPath(): PromiseLike<string>;
  getBaseName(): string;
  getParent(): Directory;
  read(flushCache: boolean): PromiseLike<string>;
  write(text: string): PromiseLike<void>;
  writeSync(text: string): void;
}

export = File;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-event-kit/3ad17c029eb8899b613cdf8229964e67fb19cef7/lib/event-kit.d.ts
declare module '~atom~pathwatcher~event-kit/lib/event-kit' {
namespace EventKit {
  class Emitter {
    clear(): void;
    dispose(): void;
    on(eventName: string, handler: (value: any) => void): Disposable;
    preempt(eventName: string, handler: (value: any) => void): Disposable;
    emit(eventName: string, value: any): void;
  }

  class Disposable {
    static isDisposable(object: Object): boolean;
    constructor(disposalAction: Function);
    dispose(): void;
  }

  class CompositeDisposable {
    constructor(...disposables: { dispose: () => any }[]);
    dispose(): void;
    add(...disposables: { dispose: () => any }[]): void;
    remove(disposable: { dispose: () => any }): void;
    clear(): void;
  }

  interface EventCallback {
    (event: any): void;
  }

  interface EventHandler {
    (callback: () => void): Disposable;
  }
}

export = EventKit;
}
declare module '~atom~pathwatcher~event-kit' {
import alias = require('~atom~pathwatcher~event-kit/lib/event-kit');
export = alias;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-pathwatcher/a40728b979faadbd2a9f9a3fe472d9350a06bf81/lib/directory.d.ts
declare module '~atom~pathwatcher/lib/directory' {

import EventKit = require('~atom~pathwatcher~event-kit');

class Directory {
  constructor(directoryPath: string, symlink?: boolean);
  create(mode?: number): PromiseLike<boolean>;
  onDidChange: (callback: () => void) => EventKit.Disposable;
  isFile(): boolean;
  isDirectory(): boolean;
  isSymbolicLink(): boolean;
  exists(): PromiseLike<boolean>;
  existsSync(): boolean;
  isRoot(): boolean;
  getPath(): string;
  getRealPathSync(): string;
  getBaseName(): string;
  relativize(): string;
  getParent(): Directory;
  getFile(filename: string): File;
  getSubdirectory(dirname: string): Directory;
  getEntriesSync(): (File | Directory)[];
  getEntries(callback: (error: Error, entries: (File | Directory)[]) => void): void;
  contains(pathToCheck: string): boolean;
}

export = Directory;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-pathwatcher/a40728b979faadbd2a9f9a3fe472d9350a06bf81/lib/main.d.ts
declare module '~atom~pathwatcher/lib/main' {
import File = require('~atom~pathwatcher/lib/file');
import Directory = require('~atom~pathwatcher/lib/directory');

export function watch(path: string, callback: (event: any, newFilePath: string) => void)
export function closeAllWatchers(): void
export function getWatchedPaths(): string[]
export {File}
export {Directory}
}
declare module '~atom~pathwatcher' {
import alias = require('~atom~pathwatcher/lib/main');
export = alias;
}

// Generated by typings
// Source: src/atom/atom.d.ts
declare module '~atom/src/atom/atom' {
// some imported modules names are prefixed with '_' to avoid conflicts with local declarations.
import EventKit = require('~atom~event-kit');
import KeymapManager = require('~atom~atom-keymap');
import FirstMate = require('~atom~first-mate');
import TextBuffer = require('~atom~text-buffer');

import BufferedProcess = require('~atom/src/atom/buffer-process');
import BufferedNodeProcess = require('~atom/src/atom/buffer-node-process');
import GitRepository = require('~atom/src/atom/git-repository');
import Notification = require('~atom/src/atom/notification');

import CommandRegistry = require('~atom/src/atom/command-registry');
import Config = require('~atom/src/atom/config');
import Clipboard = require('~atom/src/atom/clipboard');
import ContextMenuManager = require('~atom/src/atom/context-menu-manager');
import MenuManager = require('~atom/src/atom/menu-manager');
import TooltipManager = require('~atom/src/atom/tooltip-manager');
import NotificationManager = require('~atom/src/atom/notification-manager');
import Project = require('~atom/src/atom/project');
import PackageManager = require('~atom/src/atom/package-manager');
import ThemeManager = require('~atom/src/atom/theme-manager');
import StyleManager = require('~atom/src/atom/style-manager');
import DeserializerManager = require('~atom/src/atom/deserializer-manager');
import ViewRegistry = require('~atom/src/atom/view-registry');
import Workspace = require('~atom/src/atom/workspace');
import Task = require('~atom/src/atom/task');
import TextEditor = require('~atom/src/atom/text-editor');

export {BufferedNodeProcess};
export {BufferedProcess};
export {GitRepository};
export {Notification};
export {TextBuffer};
export {Point, Range} from '~atom~text-buffer'
export {File, Directory} from '~atom~pathwatcher'
export {Emitter, Disposable, CompositeDisposable} from '~atom~event-kit'
export {Task};
export {TextEditor};


global {
  namespace atom {
    export var commands: CommandRegistry;
    export var config: Config;
    export var clipboard: Clipboard;
    export var contextMenu: ContextMenuManager;
    export var menu: MenuManager;
    export var keymaps: KeymapManager;
    export var tooltips: TooltipManager;
    export var notifications: NotificationManager;
    export var project: Project;
    export var grammars: FirstMate.GrammarRegistry;
    export var packages: PackageManager;
    export var themes: ThemeManager;
    export var styles: StyleManager;
    export var deserializers: DeserializerManager;
    export var views: ViewRegistry;
    export var workspace: Workspace;

    // Extended Methods
    export function onDidBeep(callback: () => void): EventKit.Disposable;
    export function onWillThrowError(callback: (event: {
      originalError: Object;
      message: string;
      url: string;
      line: number;
      column: number;
      preventDefault(): void;
    }) => void): EventKit.Disposable;
    export function onDidThrowError(callback: (event: {
      originalError: Object;
      message: string;
      url: string;
      line: number;
      column: number;
    }) => void): EventKit.Disposable;

    // Atom Details
    export function inDevMode(): boolean;
    export function inSafeMode(): boolean;
    export function inSpecMode(): boolean;
    export function getVersion(): string;
    export function isReleasedVersion(): boolean;
    export function getWindowLoadTime(): number;
    export function getLoadSettings(): Object;

    // Managing The Atom Window
    export function open(params: {
      pathsToOpen: string[];
      newWindow: boolean;
      devMode: boolean;
      safeMode: boolean;
    }): void;
    export function close();
    export function getSize(): { width: number, height: number };
    export function setSize(width: number, height: number): void;
    export function getPosition(): { x: number, y: number };
    export function setPosition(x: number, y: number): void;

    // Extended Methods
    export function pickFolder(callback: (paths: string[]) => void): void;
    export function getCurrentWindow(): any;
    export function center(): void;
    export function focus(): void;
    export function show(): void;
    export function hide(): void;
    export function reload(): void;
    export function isMaximized(): boolean;
    export function isFullScreen(): boolean;
    export function setFullScreen(): void;
    export function toggleFullScreen(): void;

    // Messaging The User
    export function beep(): void;
    export function confirm(options: {
      message: string;
      detailedMessage?: string;
      buttons?: string[] | Array<{
        [index: string]: Function;
      }>
    }): number;

    // Managing the Dev Tools
    // Extended Methods
    export function openDevTools(): PromiseLike<void>;
    export function toggleDevTools(): PromiseLike<void>;
    export function executeJavaScriptInDevTools(): void;
  }
}
}
declare module 'atom/src/atom/atom' {
import alias = require('~atom/src/atom/atom');
export = alias;
}
declare module 'atom' {
import alias = require('~atom/src/atom/atom');
export = alias;
}
